{"version":3,"sources":["webcomponents-hi-bundle.js","node_modules/@webcomponents/html-imports/src/html-imports.js","src/post-polyfill.js","src/unresolved.js"],"names":[""],"mappings":"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","file":"webcomponents-hi.js","sourcesContent":[null,"/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n(scope => {\n\n  /********************* base setup *********************/\n  const useNative = Boolean('import' in document.createElement('link'));\n\n  // Polyfill `currentScript` for browsers without it.\n  let currentScript = null;\n  if ('currentScript' in document === false) {\n    Object.defineProperty(document, 'currentScript', {\n      get() {\n        return currentScript ||\n          // NOTE: only works when called in synchronously executing code.\n          // readyState should check if `loading` but IE10 is\n          // interactive when scripts run so we cheat. This is not needed by\n          // html-imports polyfill but helps generally polyfill `currentScript`.\n          (document.readyState !== 'complete' ?\n            document.scripts[document.scripts.length - 1] : null);\n      },\n      configurable: true\n    });\n  }\n\n  /**\n   * @param {Array|NodeList|NamedNodeMap} list\n   * @param {!Function} callback\n   * @param {boolean=} inverseOrder\n   */\n  const forEach = (list, callback, inverseOrder) => {\n    const length = list ? list.length : 0;\n    const increment = inverseOrder ? -1 : 1;\n    let i = inverseOrder ? length - 1 : 0;\n    for (; i < length && i >= 0; i = i + increment) {\n      callback(list[i], i);\n    }\n  };\n\n  /********************* path fixup *********************/\n  const CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  const CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  const STYLESHEET_REGEXP = /(<link[^>]*)(rel=['|\"]?stylesheet['|\"]?[^>]*>)/g;\n\n  // path fixup: style elements in imports must be made relative to the main\n  // document. We fixup url's in url() and @import.\n  const Path = {\n\n    fixUrls(element, base) {\n      if (element.href) {\n        element.setAttribute('href',\n          Path.resolveUrl(element.getAttribute('href'), base));\n      }\n      if (element.src) {\n        element.setAttribute('src',\n          Path.resolveUrl(element.getAttribute('src'), base));\n      }\n      if (element.localName === 'style') {\n        const r = Path.replaceUrls(element.textContent, base, CSS_URL_REGEXP);\n        element.textContent = Path.replaceUrls(r, base, CSS_IMPORT_REGEXP);\n      }\n    },\n\n    replaceUrls(text, linkUrl, regexp) {\n      return text.replace(regexp, (m, pre, url, post) => {\n        let urlPath = url.replace(/[\"']/g, '');\n        if (linkUrl) {\n          urlPath = Path.resolveUrl(urlPath, linkUrl);\n        }\n        return pre + '\\'' + urlPath + '\\'' + post;\n      });\n    },\n\n    resolveUrl(url, base) {\n      // Lazy feature detection.\n      if (Path.__workingURL === undefined) {\n        Path.__workingURL = false;\n        try {\n          const u = new URL('b', 'http://a');\n          u.pathname = 'c%20d';\n          Path.__workingURL = (u.href === 'http://a/c%20d');\n        } catch (e) {}\n      }\n\n      if (Path.__workingURL) {\n        return (new URL(url, base)).href;\n      }\n\n      // Fallback to creating an anchor into a disconnected document.\n      let doc = Path.__tempDoc;\n      if (!doc) {\n        doc = document.implementation.createHTMLDocument('temp');\n        Path.__tempDoc = doc;\n        doc.__base = doc.createElement('base');\n        doc.head.appendChild(doc.__base);\n        doc.__anchor = doc.createElement('a');\n      }\n      doc.__base.href = base;\n      doc.__anchor.href = url;\n      return doc.__anchor.href || url;\n    }\n  };\n\n  /********************* Xhr processor *********************/\n  const Xhr = {\n\n    async: true,\n\n    /**\n     * @param {!string} url\n     * @param {!function(!string, string=)} success\n     * @param {!function(!string)} fail\n     */\n    load(url, success, fail) {\n      if (!url) {\n        fail('error: href must be specified');\n      } else if (url.match(/^data:/)) {\n        // Handle Data URI Scheme\n        const pieces = url.split(',');\n        const header = pieces[0];\n        let resource = pieces[1];\n        if (header.indexOf(';base64') > -1) {\n          resource = atob(resource);\n        } else {\n          resource = decodeURIComponent(resource);\n        }\n        success(resource);\n      } else {\n        const request = new XMLHttpRequest();\n        request.open('GET', url, Xhr.async);\n        request.onload = () => {\n          // Servers redirecting an import can add a Location header to help us\n          // polyfill correctly. Handle relative and full paths.\n          // Prefer responseURL which already resolves redirects\n          // https://xhr.spec.whatwg.org/#the-responseurl-attribute\n          let redirectedUrl = request.responseURL || request.getResponseHeader('Location');\n          if (redirectedUrl && redirectedUrl.indexOf('/') === 0) {\n            // In IE location.origin might not work\n            // https://connect.microsoft.com/IE/feedback/details/1763802/location-origin-is-undefined-in-ie-11-on-windows-10-but-works-on-windows-7\n            const origin = (location.origin || location.protocol + '//' + location.host);\n            redirectedUrl = origin + redirectedUrl;\n          }\n          const resource = /** @type {string} */ (request.response || request.responseText);\n          if (request.status === 304 || request.status === 0 ||\n            request.status >= 200 && request.status < 300) {\n            success(resource, redirectedUrl);\n          } else {\n            fail(resource);\n          }\n        };\n        request.send();\n      }\n    }\n  };\n\n  /********************* importer *********************/\n\n  const isIE = /Trident/.test(navigator.userAgent) ||\n    /Edge\\/\\d./i.test(navigator.userAgent);\n\n  const importSelector = 'link[rel=import]';\n\n  // Used to disable loading of resources.\n  const importDisableType = 'import-disable';\n\n  const disabledLinkSelector = `link[rel=stylesheet][href][type=${importDisableType}]`;\n\n  const importDependenciesSelector = `${importSelector}, ${disabledLinkSelector},\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type=\"application/javascript\"],\n    script[type=\"text/javascript\"]`;\n\n  const importDependencyAttr = 'import-dependency';\n\n  const rootImportSelector = `${importSelector}:not([${importDependencyAttr}])`;\n\n  const pendingScriptsSelector = `script[${importDependencyAttr}]`;\n\n  const pendingStylesSelector = `style[${importDependencyAttr}],\n    link[rel=stylesheet][${importDependencyAttr}]`;\n\n  /**\n   * Importer will:\n   * - load any linked import documents (with deduping)\n   * - whenever an import is loaded, prompt the parser to try to parse\n   * - observe imported documents for new elements (these are handled via the\n   *   dynamic importer)\n   */\n  class Importer {\n    constructor() {\n      this.documents = {};\n      // Used to keep track of pending loads, so that flattening and firing of\n      // events can be done when all resources are ready.\n      this.inflight = 0;\n      this.dynamicImportsMO = new MutationObserver(m => this.handleMutations(m));\n      // Observe changes on <head>.\n      this.dynamicImportsMO.observe(document.head, {\n        childList: true,\n        subtree: true\n      });\n      // 1. Load imports contents\n      // 2. Assign them to first import links on the document\n      // 3. Wait for import styles & scripts to be done loading/running\n      // 4. Fire load/error events\n      this.loadImports(document);\n    }\n\n    /**\n     * @param {!(HTMLDocument|DocumentFragment|Element)} doc\n     */\n    loadImports(doc) {\n      const links = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      forEach(links, link => this.loadImport(link));\n    }\n\n    /**\n     * @param {!HTMLLinkElement} link\n     */\n    loadImport(link) {\n      const url = link.href;\n      // This resource is already being handled by another import.\n      if (this.documents[url] !== undefined) {\n        // If import is already loaded, we can safely associate it to the link\n        // and fire the load/error event.\n        const imp = this.documents[url];\n        if (imp && imp['__loaded']) {\n          link.import = imp;\n          this.fireEventIfNeeded(link);\n        }\n        return;\n      }\n      this.inflight++;\n      // Mark it as pending to notify others this url is being loaded.\n      this.documents[url] = 'pending';\n      Xhr.load(url, (resource, redirectedUrl) => {\n        const doc = this.makeDocument(resource, redirectedUrl || url);\n        this.documents[url] = doc;\n        this.inflight--;\n        // Load subtree.\n        this.loadImports(doc);\n        this.processImportsIfLoadingDone();\n      }, () => {\n        // If load fails, handle error.\n        this.documents[url] = null;\n        this.inflight--;\n        this.processImportsIfLoadingDone();\n      });\n    }\n\n    /**\n     * Creates a new document containing resource and normalizes urls accordingly.\n     * @param {string=} resource\n     * @param {string=} url\n     * @return {!DocumentFragment}\n     */\n    makeDocument(resource, url) {\n      if (!resource) {\n        return document.createDocumentFragment();\n      }\n\n      if (isIE) {\n        // <link rel=stylesheet> should be appended to <head>. Not doing so\n        // in IE/Edge breaks the cascading order. We disable the loading by\n        // setting the type before setting innerHTML to avoid loading\n        // resources twice.\n        resource = resource.replace(STYLESHEET_REGEXP, (match, p1, p2) => {\n          if (match.indexOf('type=') === -1) {\n            return `${p1} type=${importDisableType} ${p2}`;\n          }\n          return match;\n        });\n      }\n\n      let content;\n      const template = /** @type {!HTMLTemplateElement} */\n        (document.createElement('template'));\n      template.innerHTML = resource;\n      if (template.content) {\n        // This creates issues in Safari10 when used with shadydom (see #12).\n        content = template.content;\n      } else {\n        // <template> not supported, create fragment and move content into it.\n        content = document.createDocumentFragment();\n        while (template.firstChild) {\n          content.appendChild(template.firstChild);\n        }\n      }\n\n      // Support <base> in imported docs. Resolve url and remove its href.\n      const baseEl = content.querySelector('base');\n      if (baseEl) {\n        url = Path.resolveUrl(baseEl.getAttribute('href'), url);\n        baseEl.removeAttribute('href');\n      }\n\n      const n$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)>} */\n        (content.querySelectorAll(importDependenciesSelector));\n      // For source map hints.\n      let inlineScriptIndex = 0;\n      forEach(n$, n => {\n        // Listen for load/error events, then fix urls.\n        whenElementLoaded(n);\n        Path.fixUrls(n, url);\n        // Mark for easier selectors.\n        n.setAttribute(importDependencyAttr, '');\n        // Generate source map hints for inline scripts.\n        if (n.localName === 'script' && !n.src && n.textContent) {\n          const num = inlineScriptIndex ? `-${inlineScriptIndex}` : '';\n          const content = n.textContent + `\\n//# sourceURL=${url}${num}.js\\n`;\n          // We use the src attribute so it triggers load/error events, and it's\n          // easier to capture errors (e.g. parsing) like this.\n          n.setAttribute('src', 'data:text/javascript;charset=utf-8,' + encodeURIComponent(content));\n          n.textContent = '';\n          inlineScriptIndex++;\n        }\n      });\n      return content;\n    }\n\n    /**\n     * Waits for loaded imports to finish loading scripts and styles, then fires\n     * the load/error events.\n     */\n    processImportsIfLoadingDone() {\n      // Wait until all resources are ready, then load import resources.\n      if (this.inflight) return;\n\n      // Stop observing, flatten & load resource, then restart observing <head>.\n      this.dynamicImportsMO.disconnect();\n      this.flatten(document);\n      // We wait for styles to load, and at the same time we execute the scripts,\n      // then fire the load/error events for imports to have faster whenReady\n      // callback execution.\n      // NOTE: This is different for native behavior where scripts would be\n      // executed after the styles before them are loaded.\n      // To achieve that, we could select pending styles and scripts in the\n      // document and execute them sequentially in their dom order.\n      let scriptsOk = false,\n        stylesOk = false;\n      const onLoadingDone = () => {\n        if (stylesOk && scriptsOk) {\n          // Catch any imports that might have been added while we\n          // weren't looking, wait for them as well.\n          this.loadImports(document);\n          if (this.inflight) return;\n\n          // Restart observing.\n          this.dynamicImportsMO.observe(document.head, {\n            childList: true,\n            subtree: true\n          });\n          this.fireEvents();\n        }\n      }\n      this.waitForStyles(() => {\n        stylesOk = true;\n        onLoadingDone();\n      });\n      this.runScripts(() => {\n        scriptsOk = true;\n        onLoadingDone();\n      });\n    }\n\n    /**\n     * @param {!HTMLDocument} doc\n     */\n    flatten(doc) {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (doc.querySelectorAll(importSelector));\n      forEach(n$, n => {\n        const imp = this.documents[n.href];\n        n.import = /** @type {!Document} */ (imp);\n        if (imp && imp.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          // We set the .import to be the link itself, and update its readyState.\n          // Other links with the same href will point to this link.\n          this.documents[n.href] = n;\n          n.readyState = 'loading';\n          // Suppress Closure warning about incompatible subtype assignment.\n          ( /** @type {!HTMLElement} */ (n).import = n);\n          this.flatten(imp);\n          n.appendChild(imp);\n        }\n      });\n    }\n\n    /**\n     * Replaces all the imported scripts with a clone in order to execute them.\n     * Updates the `currentScript`.\n     * @param {!function()} callback\n     */\n    runScripts(callback) {\n      const s$ = document.querySelectorAll(pendingScriptsSelector);\n      const l = s$.length;\n      const cloneScript = i => {\n        if (i < l) {\n          // The pending scripts have been generated through innerHTML and\n          // browsers won't execute them for security reasons. We cannot use\n          // s.cloneNode(true) either, the only way to run the script is manually\n          // creating a new element and copying its attributes.\n          const s = s$[i];\n          const clone = /** @type {!HTMLScriptElement} */\n            (document.createElement('script'));\n          // Remove import-dependency attribute to avoid double cloning.\n          s.removeAttribute(importDependencyAttr);\n          forEach(s.attributes, attr => clone.setAttribute(attr.name, attr.value));\n          // Update currentScript and replace original with clone script.\n          currentScript = clone;\n          s.parentNode.replaceChild(clone, s);\n          whenElementLoaded(clone, () => {\n            currentScript = null;\n            cloneScript(i + 1);\n          });\n        } else {\n          callback();\n        }\n      };\n      cloneScript(0);\n    }\n\n    /**\n     * Waits for all the imported stylesheets/styles to be loaded.\n     * @param {!function()} callback\n     */\n    waitForStyles(callback) {\n      const s$ = /** @type {!NodeList<!(HTMLLinkElement|HTMLStyleElement)>} */\n        (document.querySelectorAll(pendingStylesSelector));\n      let pending = s$.length;\n      if (!pending) {\n        callback();\n        return;\n      }\n      // <link rel=stylesheet> should be appended to <head>. Not doing so\n      // in IE/Edge breaks the cascading order\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10472273/\n      // If there is one <link rel=stylesheet> imported, we must move all imported\n      // links and styles to <head>.\n      const needsMove = isIE && !!document.querySelector(disabledLinkSelector);\n      forEach(s$, s => {\n        // Listen for load/error events, remove selector once is done loading.\n        whenElementLoaded(s, () => {\n          s.removeAttribute(importDependencyAttr);\n          if (--pending === 0) {\n            callback();\n          }\n        });\n        // Check if was already moved to head, to handle the case where the element\n        // has already been moved but it is still loading.\n        if (needsMove && s.parentNode !== document.head) {\n          // Replace the element we're about to move with a placeholder.\n          const placeholder = document.createElement(s.localName);\n          // Add reference of the moved element.\n          placeholder['__appliedElement'] = s;\n          // Disable this from appearing in document.styleSheets.\n          placeholder.setAttribute('type', 'import-placeholder');\n          // Append placeholder next to the sibling, and move original to <head>.\n          s.parentNode.insertBefore(placeholder, s.nextSibling);\n          let newSibling = importForElement(s);\n          while (newSibling && importForElement(newSibling)) {\n            newSibling = importForElement(newSibling);\n          }\n          if (newSibling.parentNode !== document.head) {\n            newSibling = null;\n          }\n          document.head.insertBefore(s, newSibling);\n          // Enable the loading of <link rel=stylesheet>.\n          s.removeAttribute('type');\n        }\n      });\n    }\n\n    /**\n     * Fires load/error events for imports in the right order .\n     */\n    fireEvents() {\n      const n$ = /** @type {!NodeList<!HTMLLinkElement>} */\n        (document.querySelectorAll(importSelector));\n      // Inverse order to have events firing bottom-up.\n      forEach(n$, n => this.fireEventIfNeeded(n), true);\n    }\n\n    /**\n     * Fires load/error event for the import if this wasn't done already.\n     * @param {!HTMLLinkElement} link\n     */\n    fireEventIfNeeded(link) {\n      // Don't fire twice same event.\n      if (!link['__loaded']) {\n        link['__loaded'] = true;\n        // Update link's import readyState.\n        link.import && (link.import.readyState = 'complete');\n        const eventType = link.import ? 'load' : 'error';\n        link.dispatchEvent(newCustomEvent(eventType, {\n          bubbles: false,\n          cancelable: false,\n          detail: undefined\n        }));\n      }\n    }\n\n    /**\n     * @param {Array<MutationRecord>} mutations\n     */\n    handleMutations(mutations) {\n      forEach(mutations, m => forEach(m.addedNodes, elem => {\n        if (elem && elem.nodeType === Node.ELEMENT_NODE) {\n          // NOTE: added scripts are not updating currentScript in IE.\n          if (isImportLink(elem)) {\n            this.loadImport( /** @type {!HTMLLinkElement} */ (elem));\n          } else {\n            this.loadImports( /** @type {!Element} */ (elem));\n          }\n        }\n      }));\n    }\n  }\n\n  /**\n   * @param {!Node} node\n   * @return {boolean}\n   */\n  const isImportLink = node => {\n    return node.nodeType === Node.ELEMENT_NODE && node.localName === 'link' &&\n      ( /** @type {!HTMLLinkElement} */ (node).rel === 'import');\n  };\n\n  /**\n   * Waits for an element to finish loading. If already done loading, it will\n   * mark the element accordingly.\n   * @param {!(HTMLLinkElement|HTMLScriptElement|HTMLStyleElement)} element\n   * @param {function()=} callback\n   */\n  const whenElementLoaded = (element, callback) => {\n    if (element['__loaded']) {\n      callback && callback();\n    } else if ((element.localName === 'script' && !element.src) ||\n      (element.localName === 'style' && !element.firstChild)) {\n      // Inline scripts and empty styles don't trigger load/error events,\n      // consider them already loaded.\n      element['__loaded'] = true;\n      callback && callback();\n    } else {\n      const onLoadingDone = event => {\n        element.removeEventListener(event.type, onLoadingDone);\n        element['__loaded'] = true;\n        callback && callback();\n      };\n      element.addEventListener('load', onLoadingDone);\n      // NOTE: We listen only for load events in IE/Edge, because in IE/Edge\n      // <style> with @import will fire error events for each failing @import,\n      // and finally will trigger the load event when all @import are\n      // finished (even if all fail).\n      if (!isIE || element.localName !== 'style') {\n        element.addEventListener('error', onLoadingDone);\n      }\n    }\n  }\n\n  /**\n   * Calls the callback when all imports in the document at call time\n   * (or at least document ready) have loaded. Callback is called synchronously\n   * if imports are already done loading.\n   * @param {function()=} callback\n   */\n  const whenReady = callback => {\n    // 1. ensure the document is in a ready state (has dom), then\n    // 2. watch for loading of imports and call callback when done\n    whenDocumentReady(() => whenImportsReady(() => callback && callback()));\n  }\n\n  /**\n   * Invokes the callback when document is in ready state. Callback is called\n   *  synchronously if document is already done loading.\n   * @param {!function()} callback\n   */\n  const whenDocumentReady = callback => {\n    const stateChanged = () => {\n      // NOTE: Firefox can hit readystate interactive without document.body existing.\n      // This is anti-spec, but we handle it here anyways by waiting for next change.\n      if (document.readyState !== 'loading' && !!document.body) {\n        document.removeEventListener('readystatechange', stateChanged);\n        callback();\n      }\n    }\n    document.addEventListener('readystatechange', stateChanged);\n    stateChanged();\n  }\n\n  /**\n   * Invokes the callback after all imports are loaded. Callback is called\n   * synchronously if imports are already done loading.\n   * @param {!function()} callback\n   */\n  const whenImportsReady = callback => {\n    let imports = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(rootImportSelector));\n    let pending = imports.length;\n    if (!pending) {\n      callback();\n      return;\n    }\n    forEach(imports, imp => whenElementLoaded(imp, () => {\n      if (--pending === 0) {\n        callback();\n      }\n    }));\n  }\n\n  /**\n   * Returns the import document containing the element.\n   * @param {!Node} element\n   * @return {HTMLLinkElement|Document|undefined}\n   */\n  const importForElement = element => {\n    if (useNative) {\n      // Return only if not in the main doc!\n      return element.ownerDocument !== document ? element.ownerDocument : null;\n    }\n    let doc = element['__importDoc'];\n    if (!doc && element.parentNode) {\n      doc = /** @type {!Element} */ (element.parentNode);\n      if (typeof doc.closest === 'function') {\n        // Element.closest returns the element itself if it matches the selector,\n        // so we search the closest import starting from the parent.\n        doc = doc.closest(importSelector);\n      } else {\n        // Walk up the parent tree until we find an import.\n        while (!isImportLink(doc) && (doc = doc.parentNode)) {}\n      }\n      element['__importDoc'] = doc;\n    }\n    return doc;\n  }\n\n  const newCustomEvent = (type, params) => {\n    if (typeof window.CustomEvent === 'function') {\n      return new CustomEvent(type, params);\n    }\n    const event = /** @type {!CustomEvent} */ (document.createEvent('CustomEvent'));\n    event.initCustomEvent(type, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n    return event;\n  };\n\n  if (useNative) {\n    // Check for imports that might already be done loading by the time this\n    // script is actually executed. Native imports are blocking, so the ones\n    // available in the document by this time should already have failed\n    // or have .import defined.\n    const imps = /** @type {!NodeList<!HTMLLinkElement>} */\n      (document.querySelectorAll(importSelector));\n    forEach(imps, imp => {\n      if (!imp.import || imp.import.readyState !== 'loading') {\n        imp['__loaded'] = true;\n      }\n    });\n    // Listen for load/error events to capture dynamically added scripts.\n    /**\n     * @type {!function(!Event)}\n     */\n    const onLoadingDone = event => {\n      const elem = /** @type {!Element} */ (event.target);\n      if (isImportLink(elem)) {\n        elem['__loaded'] = true;\n      }\n    };\n    document.addEventListener('load', onLoadingDone, true /* useCapture */ );\n    document.addEventListener('error', onLoadingDone, true /* useCapture */ );\n  } else {\n    // Override baseURI so that imported elements' baseURI can be used seemlessly\n    // on native or polyfilled html-imports.\n    // NOTE: a <link rel=import> will have `link.baseURI === link.href`, as the link\n    // itself is used as the `import` document.\n    /** @type {Object|undefined} */\n    const native_baseURI = Object.getOwnPropertyDescriptor(Node.prototype, 'baseURI');\n    // NOTE: if not configurable (e.g. safari9), set it on the Element prototype. \n    const klass = !native_baseURI || native_baseURI.configurable ? Node : Element;\n    Object.defineProperty(klass.prototype, 'baseURI', {\n      get() {\n        const ownerDoc = /** @type {HTMLLinkElement} */ (isImportLink(this) ? this : importForElement(this));\n        if (ownerDoc) return ownerDoc.href;\n        // Use native baseURI if possible.\n        if (native_baseURI && native_baseURI.get) return native_baseURI.get.call(this);\n        // Polyfill it if not available.\n        const base = /** @type {HTMLBaseElement} */ (document.querySelector('base'));\n        return (base || window.location).href;\n      },\n      configurable: true,\n      enumerable: true\n    });\n\n    whenDocumentReady(() => new Importer());\n  }\n\n  /**\n    Add support for the `HTMLImportsLoaded` event and the `HTMLImports.whenReady`\n    method. This api is necessary because unlike the native implementation,\n    script elements do not force imports to resolve. Instead, users should wrap\n    code in either an `HTMLImportsLoaded` handler or after load time in an\n    `HTMLImports.whenReady(callback)` call.\n\n    NOTE: This module also supports these apis under the native implementation.\n    Therefore, if this file is loaded, the same code can be used under both\n    the polyfill and native implementation.\n   */\n  whenReady(() => document.dispatchEvent(newCustomEvent('HTMLImportsLoaded', {\n    cancelable: true,\n    bubbles: true,\n    detail: undefined\n  })));\n\n  // exports\n  scope.useNative = useNative;\n  scope.whenReady = whenReady;\n  scope.importForElement = importForElement;\n\n})(window.HTMLImports = (window.HTMLImports || {}));","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n'use strict';\n\nlet customElements = window['customElements'];\nlet HTMLImports = window['HTMLImports'];\nlet Template = window['HTMLTemplateElement'];\n\n// global for (1) existence means `WebComponentsReady` will file,\n// (2) WebComponents.ready == true means event has fired.\nwindow.WebComponents = window.WebComponents || {};\n\nif (customElements && customElements['polyfillWrapFlushCallback']) {\n  // Here we ensure that the public `HTMLImports.whenReady`\n  // always comes *after* custom elements have upgraded.\n  let flushCallback;\n  let runAndClearCallback = function runAndClearCallback() {\n    if (flushCallback) {\n      // make sure to run the HTMLTemplateElement polyfill before custom elements upgrade\n      if (Template.bootstrap) {\n        Template.bootstrap(window.document);\n      }\n      let cb = flushCallback;\n      flushCallback = null;\n      cb();\n      return true;\n    }\n  }\n  let origWhenReady = HTMLImports['whenReady'];\n  customElements['polyfillWrapFlushCallback'](function(cb) {\n    flushCallback = cb;\n    origWhenReady(runAndClearCallback);\n  });\n\n  HTMLImports['whenReady'] = function(cb) {\n    origWhenReady(function() {\n      // custom element code may add dynamic imports\n      // to match processing of native custom elements before\n      // domContentLoaded, we wait for these imports to resolve first.\n      if (runAndClearCallback()) {\n        HTMLImports['whenReady'](cb);\n      } else {\n        cb();\n      }\n    });\n  }\n\n}\n\nHTMLImports['whenReady'](function() {\n  requestAnimationFrame(function() {\n    window.WebComponents.ready = true;\n    document.dispatchEvent(new CustomEvent('WebComponentsReady', {bubbles: true}));\n  });\n});","/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n'use strict';\n// It's desireable to provide a default stylesheet\n// that's convenient for styling unresolved elements, but\n// it's cumbersome to have to include this manually in every page.\n// It would make sense to put inside some HTMLImport but\n// the HTMLImports polyfill does not allow loading of stylesheets\n// that block rendering. Therefore this injection is tolerated here.\n//\n// NOTE: position: relative fixes IE's failure to inherit opacity\n// when a child is not statically positioned.\nlet style = document.createElement('style');\nstyle.textContent = ''\n    + 'body {'\n    + 'transition: opacity ease-in 0.2s;'\n    + ' } \\n'\n    + 'body[unresolved] {'\n    + 'opacity: 0; display: block; overflow: hidden; position: relative;'\n    + ' } \\n'\n    ;\nlet head = document.querySelector('head');\nhead.insertBefore(style, head.firstChild);"]}